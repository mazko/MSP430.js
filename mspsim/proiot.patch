diff --git a/Makefile b/Makefile
index 427ffe5..d74e833 100644
--- a/Makefile
+++ b/Makefile
@@ -81,7 +81,7 @@ TIMERTEST := tests/timertest.firmware
 SCRIPTS := ${addprefix scripts/,autorun.sc duty.sc}
 BINARY := README.txt license.txt CHANGE_LOG.txt images/*.jpg images/*.png firmware/*/*.firmware ${SCRIPTS}
 
-PACKAGES := se/sics/mspsim ${addprefix se/sics/mspsim/,core chip cli config debug platform ${addprefix platform/,esb sky jcreate sentillausb z1 tyndall ti wismote} plugin profiler emulink net ui util extutil/highlight extutil/jfreechart}
+PACKAGES := se/sics/mspsim ${addprefix se/sics/mspsim/,core chip cli config debug platform ${addprefix platform/,esb sky jcreate sentillausb z1 tyndall ti wismote proiot3 proiot4} plugin profiler emulink net ui util extutil/highlight extutil/jfreechart}
 
 SOURCES := ${wildcard *.java $(addsuffix /*.java,$(PACKAGES))}
 
@@ -105,7 +105,7 @@ $(JARFILE):	$(OBJECTS)
 	-@$(RM) JarManifest.txt
 	@echo >>JarManifest.txt "Manifest-Version: 1.0"
 	@echo >>JarManifest.txt "Sealed: true"
-	@echo >>JarManifest.txt "Main-Class: se.sics.mspsim.Main"
+	@echo >>JarManifest.txt "Main-Class: se.sics.mspsim.emulink.WSEmuLink"
 	@echo >>JarManifest.txt "Class-path: ${LIBS}"
 	$(JAR) cfm $(JARFILE) JarManifest.txt images/*.jpg -C $(BUILD) .
 	-@$(RM) JarManifest.txt
diff --git a/se/sics/mspsim/core/MSP430.java b/se/sics/mspsim/core/MSP430.java
index 15dc730..a770cfd 100644
--- a/se/sics/mspsim/core/MSP430.java
+++ b/se/sics/mspsim/core/MSP430.java
@@ -50,8 +50,8 @@ public class MSP430 extends MSP430Core {
   private int tracePos;
   
   private boolean debug = false;
-  private boolean running = false;
-  private boolean isBreaking = false;
+  volatile private boolean running = false;
+  volatile private boolean isBreaking = false;
   private double rate = 2.0;
 
   // Debug time - measure cycles
@@ -89,6 +89,9 @@ public class MSP430 extends MSP430Core {
       throw new IllegalStateException("already running");
     }
     setRunning(true);
+    if (proiotPatchFixStopBeforeStarted) {
+      isStopping = true;
+    }
     try {
         // ??? - power-up  should be executed?!
         time = System.currentTimeMillis();
@@ -307,7 +310,10 @@ public class MSP430 extends MSP430Core {
     return lastReturnedMicros;
   }
 
+  private volatile boolean proiotPatchFixStopBeforeStarted;
+
   public void stop() {
+      proiotPatchFixStopBeforeStarted = true;
       isStopping = true;
   }
 
diff --git a/se/sics/mspsim/core/MSP430Core.java b/se/sics/mspsim/core/MSP430Core.java
index da7ed56..077c251 100644
--- a/se/sics/mspsim/core/MSP430Core.java
+++ b/se/sics/mspsim/core/MSP430Core.java
@@ -75,7 +75,7 @@ public class MSP430Core extends Chip implements MSP430Constants {
   public final int memory[];
   private final Flash flash;
   boolean isFlashBusy;
-  boolean isStopping = false;
+  volatile boolean isStopping = false;
 
   private final Memory memorySegments[];
   Memory currentSegment;
diff --git a/se/sics/mspsim/emulink/EmuLink.java b/se/sics/mspsim/emulink/EmuLink.java
index 155af60..a13d541 100755
--- a/se/sics/mspsim/emulink/EmuLink.java
+++ b/se/sics/mspsim/emulink/EmuLink.java
@@ -56,7 +56,7 @@ import se.sics.mspsim.core.MSP430Constants;
 import se.sics.mspsim.platform.GenericNode;
 import se.sics.mspsim.util.Utils;
 
-public class EmuLink {
+public class EmuLink implements IEmuLinkWriter {
 
     private Socket socket;
     private BufferedReader in;
@@ -65,7 +65,7 @@ public class EmuLink {
     private long globalEtime = 0L;
     private long globalLastTime = 0L;
 
-    private final Hashtable<String, GenericNode> nodes = new Hashtable<String, GenericNode>();
+    protected final Hashtable<String, GenericNode> nodes = new Hashtable<String, GenericNode>();
 
     public boolean isConnected() {
         return !isConnected;
@@ -97,6 +97,11 @@ public class EmuLink {
             return false;
         }
         nodes.put(id, node);
+
+        if (node instanceof se.sics.mspsim.platform.IProiotNode) {
+          ((se.sics.mspsim.platform.IProiotNode)node).setEmuLink(this);
+        }
+
         return true;
     }
     
@@ -151,8 +156,12 @@ public class EmuLink {
         }
     };
 
+    private static String upToNCharacters(final String s, final int n) {
+        return s.substring(0, Math.min(s.length(), n));
+    }
+
     protected boolean handleMessage(JSONObject json) {
-        System.out.println("EmuLink: RECV " + json.toJSONString());
+        System.out.println("EmuLink: RECV " + upToNCharacters(json.toJSONString(), 333));
         String event = json.getAsString("event");
         if ("emulation_control".equals(event)) {
             String command = json.getAsString("data");
@@ -228,8 +237,25 @@ public class EmuLink {
 
                 // Time to close the connection
                 return false;
+            } else if (command.startsWith("proiot$")) {
+                String[] nodes = getNodes(json);
+                Object cmdValue = json.get("proiot$value");
+                if (nodes == null) {
+                    for (GenericNode node : this.nodes.values()) {
+                        ((se.sics.mspsim.platform.IProiotNode)node).handleMoreCmd(command, cmdValue);
+                    }
+                } else {
+                    for(String id : nodes) {
+                        GenericNode node = this.nodes.get(id);
+                        if (node != null) {
+                            ((se.sics.mspsim.platform.IProiotNode)node).handleMoreCmd(command, cmdValue);
+                        } else {
+                            System.err.println("EmuLink: could not find node '" + id + "'");
+                        }
+                    }
+                }
             }
-            sendToSimulator("{\"response\":\"emulation_control\",\"data\":1}");
+            sendToSimulator("{\"response\":\"emulation_control\",\"data\":\"" + command + "\"}");
 
         } else if ("create".equals(event)) {
             createNodes(json);
@@ -237,11 +263,12 @@ public class EmuLink {
         } else if ("write".equals(event)) {
             String[] nodes = getNodes(json);
             String file = json.getAsString("file");
+            JSONArray elf8 = json.getJSONArray("elf8");
             if (nodes == null) {
                 System.err.println("EmuLink: no node specified for write");
-            } else if (file == null) {
-                System.err.println("EmuLink: no file specified for write");
-            } else if (!new File(file).isFile()) {
+            } else if (file == null && elf8 == null) {
+                System.err.println("EmuLink: no file or elf8 specified for write");
+            } else if (elf8 == null && !new File(file).isFile()) {
                 System.err.println("EmuLink: could not find file '" + file + "' for write");
             } else {
                 for(String id : nodes) {
@@ -251,7 +278,20 @@ public class EmuLink {
                         continue;
                     }
                     try {
-                        node.loadFirmware(file);
+                        if (elf8 == null) {
+                            node.loadFirmware(file);
+                        } else {
+                            byte[] elfBytes = new byte[elf8.size()];
+                            for(int i = 0; i < elfBytes.length; i++) {
+                                elfBytes[i] = (byte)(long)elf8.get(i);
+                            }
+                            // System.err.println(java.util.Arrays.toString(elfBytes));
+                            // try (java.io.FileOutputStream s = new java.io.FileOutputStream("bytes.dump.elf")) { s.write(elfBytes); }
+                            // echo `md5sum bytes.dump.elf | awk '{ print $1}'` firmware/proiot/a.out | md5sum -c -
+                            se.sics.mspsim.util.ELF elf = new se.sics.mspsim.util.ELF(elfBytes);
+                            elf.readAll();
+                            node.loadFirmware(elf);
+                        }
                         node.getCPU().reset();
                     } catch (IOException e) {
                         System.err.println("EmuLink: failed to load firmware '" + file + "'");
@@ -286,13 +326,17 @@ public class EmuLink {
         return true;
     }
 
-    protected void sendToSimulator(String message) {
+    @Override
+    public synchronized void sendToSimulator(String message) {
         if (out != null) {
             out.write(message);
             out.flush();
         }
     }
 
+    @Override
+    public void simulationStopped() {}
+
     protected void sendSerialToNode(String node, int data) {
     }
 
diff --git a/se/sics/mspsim/emulink/IEmuLinkWriter.java b/se/sics/mspsim/emulink/IEmuLinkWriter.java
new file mode 100644
index 0000000..0a782ba
--- /dev/null
+++ b/se/sics/mspsim/emulink/IEmuLinkWriter.java
@@ -0,0 +1,6 @@
+package se.sics.mspsim.emulink;
+
+public interface IEmuLinkWriter {
+  void sendToSimulator(String message);
+  void simulationStopped();
+}
\ No newline at end of file
diff --git a/se/sics/mspsim/emulink/WSEmuLink.java b/se/sics/mspsim/emulink/WSEmuLink.java
new file mode 100644
index 0000000..ca40786
--- /dev/null
+++ b/se/sics/mspsim/emulink/WSEmuLink.java
@@ -0,0 +1,74 @@
+package se.sics.mspsim.emulink;
+
+
+import io.undertow.server.DefaultByteBufferPool;
+
+import io.undertow.Handlers;
+import io.undertow.Undertow;
+import io.undertow.server.handlers.PathHandler;
+import io.undertow.server.handlers.resource.PathResourceManager;
+import io.undertow.servlet.api.DeploymentInfo;
+import io.undertow.servlet.api.DeploymentManager;
+import io.undertow.servlet.api.ServletContainer;
+import io.undertow.websockets.jsr.WebSocketDeploymentInfo;
+import io.undertow.servlet.api.ErrorPage;
+import io.undertow.util.StatusCodes;
+
+import org.xnio.Xnio;
+import org.xnio.XnioWorker;
+import org.xnio.OptionMap;
+import org.xnio.Options;
+
+import java.nio.file.Paths;
+
+
+public class WSEmuLink {
+
+    static String argOrDefault(String[] args, int idx, String def) {
+        return idx < args.length ? args[idx] : def;
+    }
+
+    public static void main(final String[] args) throws Exception {
+
+        PathHandler path = Handlers.path();
+
+        Undertow server = Undertow.builder()
+            .addHttpListener(
+                Integer.valueOf(argOrDefault(args, 0, "9148")), 
+                argOrDefault(args, 1, "localhost"))
+            .setHandler(path)
+            .build();
+        server.start();
+
+        final ServletContainer container = ServletContainer.Factory.newInstance();
+
+        // see undertow/../testutils/DefaultServer.java
+        XnioWorker worker = Xnio.getInstance().createWorker(OptionMap.builder()
+            .set(Options.WORKER_IO_THREADS, 8)
+            .set(Options.CONNECTION_HIGH_WATER, 1000000)
+            .set(Options.CONNECTION_LOW_WATER, 1000000)
+            .set(Options.WORKER_TASK_CORE_THREADS, 30)
+            .set(Options.WORKER_TASK_MAX_THREADS, 30)
+            .set(Options.TCP_NODELAY, true)
+            .set(Options.CORK, true)
+            .getMap());
+
+        DeploymentInfo builder = new DeploymentInfo()
+            .setClassLoader(WSEmuLink.class.getClassLoader())
+            .setContextPath("/")
+            .addWelcomePage("index.html")
+            .setResourceManager(new PathResourceManager(Paths.get("./webapp")))
+            .addServletContextAttribute(WebSocketDeploymentInfo.ATTRIBUTE_NAME,
+                new WebSocketDeploymentInfo()
+                    .setBuffers(new DefaultByteBufferPool(true, 100))
+                    .setWorker(worker)
+                    .addEndpoint(WSEmuLinkEndpoint.class)
+            )
+            .setDeploymentName("WSEmuLink")
+            .addErrorPage(new ErrorPage("/404.html", StatusCodes.NOT_FOUND));
+
+        DeploymentManager manager = container.addDeployment(builder);
+        manager.deploy();
+        path.addPrefixPath("/", manager.start());
+    }
+}
diff --git a/se/sics/mspsim/emulink/WSEmuLinkEndpoint.java b/se/sics/mspsim/emulink/WSEmuLinkEndpoint.java
new file mode 100644
index 0000000..f20c05d
--- /dev/null
+++ b/se/sics/mspsim/emulink/WSEmuLinkEndpoint.java
@@ -0,0 +1,225 @@
+package se.sics.mspsim.emulink;
+
+import java.io.IOException;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
+import java.nio.ByteBuffer;
+
+import se.sics.json.JSONObject;
+import se.sics.json.ParseException;
+import se.sics.mspsim.platform.GenericNode;
+
+import javax.websocket.CloseReason;
+import javax.websocket.OnClose;
+import javax.websocket.OnMessage;
+import javax.websocket.OnOpen;
+import javax.websocket.OnError;
+import javax.websocket.Session;
+import javax.websocket.server.ServerEndpoint;
+import javax.websocket.MessageHandler;
+
+
+// https://gist.github.com/mnstrspeed/9295199
+// https://abhirockzz.gitbooks.io/java-websocket-api-handbook/
+// https://hpbn.co/websocket/
+
+
+final class Assert {
+
+  private Assert() {}
+
+  static void ok(boolean cond, String msg) {
+    if (!cond) {
+      System.err.println("!!! ASSERT !!!: " + msg);
+      System.exit(42);
+    }
+  }
+
+  static void fail(String msg) {
+    ok(false, msg);
+  }
+}
+
+
+interface IEmuLinkTerminator {
+    void terminate();
+}
+
+
+class EmuLinkWrapper extends EmuLink {
+
+    // https://stackoverflow.com/a/38199247
+    // if your ServerEndpoint class needs to deal with instance variables in
+    // multiple methods for some reason, it must be implemented in a thread safe manner.
+
+    private final Object padLock = new Object();
+
+    public boolean handleMessage(String msg) throws ParseException {
+        // http://juliusdavies.ca/json-simple-1.1.1-javadocs/org/json/simple/parser/JSONParser.html
+        // Please note that JSONParser is NOT thread-safe.
+        // but https://stackoverflow.com/a/5173439
+        JSONObject json = JSONObject.parseJSONObject(msg);
+        synchronized (padLock) {
+            return handleMessage(json);
+        }
+    }
+
+    public void stopAll(String reason) {
+        sendQueue.clear();
+        putToSendQueue(poison);
+        synchronized (padLock) {
+            for (GenericNode node : this.nodes.values()) {
+                if (node.getCPU().isRunning()) {
+                    System.out.println(node + " stopped because of " + reason);
+                }
+                node.stop();
+            }
+        }       
+    }
+
+    // https://pragprog.com/magazines/2013-05/java-active-objects
+    private final LinkedBlockingQueue<String> sendQueue = new LinkedBlockingQueue<>();
+
+    private static final String poison = new String();
+
+    void putToSendQueue(String str) {
+        Assert.ok(str != null, "putToSendQueue str can't be null");
+        try {
+            sendQueue.put(str);
+        } catch (Exception e) {
+            e.printStackTrace();
+            Assert.fail("putToSendQueue");
+        }
+    }
+
+    EmuLinkWrapper(final Session session) {
+        new Thread () {   
+            @Override 
+            public void run() {   
+                try {
+                    while(true) {
+                        String msg = sendQueue.poll(5, TimeUnit.SECONDS);
+                        if (msg == poison) {
+                            break;
+                        } else if (msg == null /* timeout */) {
+                            // https://github.com/websockets/ws#how-to-detect-and-close-broken-connections
+                            // Sometimes the link between the server and the client can be 
+                            // interrupted in a way that keeps both the server and the client 
+                            // unaware of the broken state of the connection (e.g. when pulling the cord).
+                            // In these cases ping messages can be used as a means to 
+                            // verify that the remote endpoint is still responsive.
+                            // ------------------------------------------------------
+                            // https://github.com/undertow-io/undertow/blob/master/websockets-jsr/src/main/java/io/undertow/websockets/jsr/WebSocketSessionRemoteEndpoint.java#L377
+                            // sendPing => WebSockets.sendPingBlocking
+                            // https://github.com/undertow-io/undertow/blob/master/core/src/main/java/io/undertow/websockets/core/WebSockets.java#L557
+                            // sendPingBlocking => sendBlockingInternal
+                            session.getBasicRemote().sendPing(ByteBuffer.wrap("$".getBytes()));
+                        } else {
+                            // https://github.com/undertow-io/undertow/blob/master/websockets-jsr/src/main/java/io/undertow/websockets/jsr/WebSocketSessionRemoteEndpoint.java#L253
+                            // sendText => WebSockets.sendTextBlocking
+                            // https://github.com/undertow-io/undertow/blob/master/core/src/main/java/io/undertow/websockets/core/WebSockets.java#L198
+                            // sendTextBlocking => sendBlockingInternal
+                            session.getBasicRemote().sendText(msg);
+                        }
+                    }
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    WSEmuLinkEndpoint.closeSessionHlpr(session);
+                    System.out.println("Assume it's OK...");
+                }
+                System.out.println("Active Object thread stopped...");
+            }
+        }.start();
+    }
+}
+
+
+@ServerEndpoint(value = "/emulink")
+public class WSEmuLinkEndpoint {
+
+    @OnOpen
+    public void onOpen(final Session session) {
+
+        System.out.println("Connected ... " + session.getId());
+        // System.out.println("Thread onOpen # " + Thread.currentThread().getId());
+
+        final EmuLinkWrapper emulink = new EmuLinkWrapper(session) {
+
+            // https://blogs.oracle.com/pavelbucek/is-websocket-session-really-thread-safe
+            // 2+ threads: onMessage->EmuLink response + GenericNode[].run
+            // http://docs.oracle.com/javaee/7/api/javax/websocket/Session.html
+            // - Session objects may be called by multiple threads. Implementations must ensure the integrity of the mutable properties of the session under such circumstances.
+            // http://docs.oracle.com/javaee/7/api/javax/websocket/RemoteEndpoint.Basic.html
+            // - if two threads attempt to call a send method concurrently, or if a developer attempts to send a new message while in the middle of sending an existing one, the send method called while the connection is already busy may throw an IllegalStateException.
+            @Override
+            public void sendToSimulator(String message) {
+                // it's a shame. Can't find any jsr356 specification about
+                // is session.getAsyncRemote().sendX guarantee sequentially sendX
+                // just for sure use simplified ActiveObject pattern + getBasicRemote
+                putToSendQueue(message);
+            }
+
+            @Override
+            public void simulationStopped() {
+                WSEmuLinkEndpoint.closeSessionHlpr(session);
+            }
+        };
+
+        session.addMessageHandler(new MessageHandler.Whole<String>() {
+
+            @Override
+            public void onMessage(String message) {
+                // System.out.println("Thread onMessage # " + Thread.currentThread().getId());
+                // tyrus-grizzly-server: onMessage each time different thread
+                // undertow: onOpen/onMessage different thread
+                try {
+                    if (!emulink.handleMessage(message)) {
+                        // currently not used and not tested
+                        System.out.println("JSON close socket command received ? " + message);
+                        session.close();
+                    }
+                    Assert.ok(session.isOpen(), "Dead session can't handle message");
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    Assert.fail("onMessage");
+                }
+            }
+        });
+
+        session.getUserProperties().put("terminator", new IEmuLinkTerminator () {
+            @Override
+            public void terminate() {
+                emulink.stopAll("Session Closed");
+            }
+        });
+
+    }
+ 
+ 
+    @OnClose
+    public void onClose(Session session, CloseReason closeReason) {
+        // System.out.println("Thread onClose # " + Thread.currentThread().getId());
+        System.out.println(String.format("Session %s closed because of %s", session.getId(), closeReason));
+        ((IEmuLinkTerminator)session.getUserProperties().get("terminator")).terminate();
+    }
+
+
+    @OnError
+    public void onError(Session session, Throwable t) {
+        t.printStackTrace();
+        closeSessionHlpr(session);
+    }
+
+    static void closeSessionHlpr(Session session) {
+        // http://docs.oracle.com/javaee/7/api/javax/websocket/Session.html
+        // Following the convention of Closeable calling the Session close() methods after the Session has been closed has no effect.
+        try {
+            session.close();
+        } catch (Exception e) {
+            e.printStackTrace();
+            Assert.fail("closeSessionHlpr");
+        }
+    }
+
+}
diff --git a/se/sics/mspsim/platform/IProiotNode.java b/se/sics/mspsim/platform/IProiotNode.java
new file mode 100644
index 0000000..80e11d6
--- /dev/null
+++ b/se/sics/mspsim/platform/IProiotNode.java
@@ -0,0 +1,8 @@
+package se.sics.mspsim.platform;
+
+import se.sics.mspsim.emulink.IEmuLinkWriter;
+
+public interface IProiotNode {
+  void setEmuLink(IEmuLinkWriter emulink);
+  void handleMoreCmd(String cmd, Object value);
+}
diff --git a/se/sics/mspsim/platform/proiot3/Assert.java b/se/sics/mspsim/platform/proiot3/Assert.java
new file mode 100644
index 0000000..5bbe995
--- /dev/null
+++ b/se/sics/mspsim/platform/proiot3/Assert.java
@@ -0,0 +1,18 @@
+package se.sics.mspsim.platform.proiot3;
+
+
+public final class Assert {
+
+  private Assert() {}
+
+  static void ok(boolean cond, String msg) {
+    if (!cond) {
+      System.err.println("!!! ASSERT !!!: " + msg);
+      System.exit(42);
+    }
+  }
+
+  static void fail(String msg) {
+    ok(false, msg);
+  }
+}
diff --git a/se/sics/mspsim/platform/proiot3/Enc28J60.java b/se/sics/mspsim/platform/proiot3/Enc28J60.java
new file mode 100644
index 0000000..7c30441
--- /dev/null
+++ b/se/sics/mspsim/platform/proiot3/Enc28J60.java
@@ -0,0 +1,363 @@
+package se.sics.mspsim.platform.proiot3;
+
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.ArrayDeque;
+import java.util.Queue;
+
+import se.sics.mspsim.core.Chip;
+import se.sics.mspsim.core.MSP430Core;
+import se.sics.mspsim.core.USARTListener;
+import se.sics.mspsim.core.USARTSource;
+import se.sics.mspsim.platform.GenericNode;
+
+import com.sun.jna.LastErrorException;
+
+// previous: https://gist.github.com/e89c9f685988660ceb6114e3b7f2d6f0
+
+public class Enc28J60 extends Chip implements USARTListener {
+
+  // https://github.com/tom-seddon/fuse-emulator-code/blob/master/fuse/peripherals/nic/enc28j60.c
+
+  private enum SPI_STATE {
+    SPI_IDLE(-2),
+    SPI_CMD (-1),  /* expect a command byte */
+
+    SPI_RCR (0),   /* read command register */
+    SPI_RBM (1),   /* read buffer memory */
+    SPI_WCR (2),   /* write command register */
+    SPI_WBM (3),   /* write buffer memory */
+    SPI_BFS (4),   /* bit-field set */
+    SPI_BFC (5),   /* bit-field clear */
+    SPI_XXX (6),   /* unknown ? */
+    SPI_SRC (7);   /* system reset command */
+
+    private final int numVal;
+
+    SPI_STATE(int numVal) {
+        this.numVal = numVal;
+    }
+
+    public static SPI_STATE fromNum(int id) {
+      for (SPI_STATE type : SPI_STATE.values()) {
+        if (type.numVal == id) {
+            return type;
+        }
+      }
+      throw new IllegalArgumentException(id + " ?");
+    }
+  }
+
+
+  private enum REG {
+    ESTAT   (0, 0x1d),
+    ECON2   (0, 0x1e),
+    ECON1   (0, 0x1f),
+    EPKTCNT (1, 0x19);
+
+    private final int bank, addr;
+
+    REG(int bank, int addr) {
+      Assert.ok( (bank & 0x3) == bank, "bank ? " + bank);
+      Assert.ok( (addr & 0x1f) == addr, "addr ? " + addr);
+      this.bank = bank;
+      this.addr = addr;
+    }
+
+    public int getValue(int[][] registers) {
+      return registers[bank][addr];
+    }
+
+    public void setValue(int value, int[][] registers) {
+      Assert.ok( (value & 0xff) == value, " byte setValue ? " + value);
+      registers[bank][addr] = value;
+    }
+  }
+
+  // be careful, don't move this inside REG (reentrancy) 
+  private int[][] registers = new int[4][32];
+
+  private void regSetValue(REG reg, int value) {
+    reg.setValue(value, registers);
+  }
+
+  private int regGetValue(REG reg) {
+    return reg.getValue(registers);
+  }
+
+  private boolean regBitTest(REG reg, int bit) {
+    Assert.ok( bit < 8 && bit >= 0 , "bit ? " + bit);
+    return ( reg.getValue(registers) & (1 << bit) ) != 0;
+  }
+
+  private void regBitClr(REG reg, int bit) {
+    Assert.ok(regBitTest(reg, bit), reg + " regBitClr ?");
+    regSetValue( reg, regGetValue(reg) & ~(1 << bit) );
+    Assert.ok(!regBitTest(reg, bit), reg + " still set ? ");
+  }
+
+  private SPI_STATE spi_state;
+
+  int curr_register, curr_register_bank;
+
+  private boolean DEBUG = true;
+
+  // https://docs.oracle.com/javase/7/docs/api/java/util/ArrayDeque.html
+  // add(E) is equivalent to addLast(E)
+  // element() is equivalent to getFirst(). Retrieves, but does not remove
+  // remove() is equivalent to removeFirst()
+  private final Queue<Byte> wbmData = new ArrayDeque<>();
+
+  // https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentLinkedDeque.html
+  // addLast(E) is equivalent to add(E)
+  // element() is equivalent to getFirst(). Retrieves, but does not remove
+  // remove() is equivalent to removeFirst()
+  private final Queue<Queue<Byte>> rbmPackets = new ConcurrentLinkedDeque<>();
+
+  private final Observable.Observer<byte[]> tapObserver;
+
+  public void chipSelect(boolean chipSelect) {
+    // log("CS: " + chipSelect);
+    if (chipSelect) {
+      spi_state = SPI_STATE.SPI_CMD;
+    } else {
+      spi_state = SPI_STATE.SPI_IDLE;
+    }
+  }
+
+  public Enc28J60(final MSP430Core cpu, final GenericNode node) {
+    super("Enc28J60", "Proiot Ethernet", cpu);
+    tapObserver = new Observable.Observer<byte[]>() {
+      @Override
+      public void update(byte[] data) {
+        final int CRC_LEN = 4;
+        final int len = data.length + CRC_LEN;
+        Queue<Byte> packet = new ArrayDeque<>();
+
+        packet.add(new Byte((byte) 0x00)); /* ignored: next packet pointer */
+        packet.add(new Byte((byte) 0x00)); /* ignored: next packet pointer */
+
+        // 39662a.pdf FIGURE 7-3. Received Byte Count.
+        // Indicates length of the received frame. This includes the destination
+        // address, source address, type/length, data, padding and CRC fields. This
+        // field is stored in little-endian format.
+        packet.add(new Byte((byte) (len & 0xff))); /* status[7:0] Received Byte Count */
+        packet.add(new Byte((byte) ((len >> 8) & 0xff))); /* status[15:8] Received Byte Count */
+
+        packet.add(new Byte((byte) 0x80)); /* status[23:16]: success (1 << 23) */
+        packet.add(new Byte((byte) 0x00)); /* status[31:24]: ignored */
+
+        for (byte b : data) {
+          packet.add(new Byte(b)); /* data */
+        }
+
+        for (int i = 0; i < CRC_LEN; i++) {
+          packet.add(new Byte((byte) 0x00)); /* ignore crc */
+        }
+
+        Assert.ok(len == packet.size() - 6 /* next packet pointer + status */, "Received Byte Count");
+
+        // TODO: memory leak
+        // 39662a.pdf 12.1.2 RECEIVE ERROR INTERRUPT FLAG (RXERIF)
+        // When a packet is being received and the receive buffer
+        // runs completely out of space, or EPKTCNT is 255 and
+        // cannot be incremented, the packet being received will
+        // be aborted (permanently lost) and the EIR.RXERIF bit
+        // will be set to ‘1’. Once set, RXERIF can only be cleared
+        // by the host controller or by a Reset condition.
+        if (rbmPackets.size() >= 0xFF) {
+          log("Assert: nr pending packets >= 0xFF, not implemented yet");
+          node.stop();
+        } else {
+          // https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentLinkedDeque.html
+          // Memory consistency effects: 
+          // As with other concurrent collections, actions in a thread prior to placing 
+          // an object into a ConcurrentLinkedDeque happen-before actions subsequent to 
+          // the access or removal of that element from the ConcurrentLinkedDeque in another thread.
+          rbmPackets.add(packet);
+          log("nr pending packets increased to: " + rbmPackets.size());
+        }
+      }
+    };
+  }
+
+  @Override
+  public void log(String msg) {
+    if (DEBUG) {
+      System.out.println("Enc28J60: [" + Integer.toHexString(System.identityHashCode(this)) + "] " + msg);
+    }
+  }
+
+  private void perform_side_effects_for_write() {
+    final int ECON2_PKTDEC_BIT = 6;
+    final int ECON1_TXRTS_BIT  = 3;
+
+    /* PKTDEC: decrease EPKTCNT */
+    if ( regBitTest(REG.ECON2, ECON2_PKTDEC_BIT) ) {
+
+      regBitClr(REG.ECON2, ECON2_PKTDEC_BIT);
+
+      if (rbmPackets.isEmpty()) {
+        log("warning, ECON2_PKTDEC_BIT has no effect (rbm is empty)");
+      } else {
+        if (rbmPackets.element().size() == 0 || rbmPackets.element().size() == 4 /*throw out crc*/) {
+          log("nr pending packets decreased to: " + (rbmPackets.size() - 1));
+        } else {
+          log("warning, rbm packet consumed partially " + rbmPackets.element().size());
+        }
+        rbmPackets.remove();
+      }
+    }
+
+    /* TXRTS: transmission request */
+    if ( regBitTest(REG.ECON1, ECON1_TXRTS_BIT )) {
+      
+      regBitClr(REG.ECON1, ECON1_TXRTS_BIT);
+
+      if (wbmData.size() > 0) {
+        log("Transmitting packet, size: " + wbmData.size());
+        // ignore first non-Ethernet byte
+        // (ENC28J60 requires a single per packet control byte to precede the packet for transmission)
+        wbmData.remove(); 
+
+        Byte[] tmp = wbmData.toArray(new Byte[0]);
+        byte[] bytes = new byte[tmp.length];
+        for(int i = 0; i < bytes.length; i++) {
+          bytes[i] = tmp[i];
+        }
+
+        try {
+          TunTap.getInstance().write(bytes);
+        } catch (Exception ex) {
+          ex.printStackTrace();
+          Assert.fail("Tap write error");
+        }
+
+        wbmData.clear();
+      } else {
+        log("warning: nothing to transmit");
+      }
+    }
+  }
+
+  private int inputByte(final int data) {
+
+    switch (spi_state) {
+      case SPI_CMD:
+        spi_state = SPI_STATE.fromNum( (data >> 5) & 0x07 /* 0x07 is optcode */ );
+
+        if ( spi_state == SPI_STATE.SPI_SRC ) {
+          log("reset not implemented yet");
+          break;
+        }
+
+        // The Control Register memory is partitioned into four
+        // banks, selectable by the bank select bits
+        // BSEL1:BSEL0 in the ECON1 register. Each bank is
+        // 32 bytes long and addressed by a 5-bit address value.
+        // The last five locations (1Bh to 1Fh) of all banks point to a
+        // common set of registers: EIE, EIR, ESTAT, ECON2 and
+        // ECON1. These are key registers used in controlling and
+        // monitoring the operation of the device. Their common
+        // mapping allows easy access without switching the bank.
+
+        curr_register = (data & 0x1f /* 5-bit address value */);
+        curr_register_bank = (curr_register >= 0x1b) ? 0 : (regGetValue(REG.ECON1) & 0x03 /* 0x03 is BSEL1:BSEL0 */);
+        // log("reg: 0x" + Integer.toHexString(curr_register) + ", bank: " + curr_register_bank + ", optcode " + spi_state);
+        break;
+
+      case SPI_WCR:
+        // log("reg: 0x" + Integer.toHexString(curr_register) + ", bank: " + curr_register_bank + ", data " + data + ", optcode " + spi_state);
+        registers[ curr_register_bank ][ curr_register ] = data;
+        perform_side_effects_for_write();
+        break;
+
+      case SPI_WBM:
+        /* Assume ECON2:AUTOINC to be set */
+        wbmData.add(new Byte((byte) data));
+        break;
+
+      case SPI_BFS:
+        // log("reg: 0x" + Integer.toHexString(curr_register) + ", bank: " + curr_register_bank + ", data " + data + ", optcode " + spi_state);
+        registers[ curr_register_bank ][ curr_register ] |= data;
+        perform_side_effects_for_write();
+        break;
+
+      case SPI_BFC:
+        // log("reg: 0x" + Integer.toHexString(curr_register) + ", bank: " + curr_register_bank + ", data " + data + ", optcode " + spi_state);
+        registers[ curr_register_bank ][ curr_register ] &= ~data;
+        // perform_side_effects_for_write();
+        break;
+
+      case SPI_RCR:
+        regSetValue(REG.EPKTCNT, rbmPackets.size());
+        regSetValue(REG.ESTAT, 0x01 /* chip is always ready CLKRDY is set */); 
+        return registers[ curr_register_bank ][ curr_register ];
+
+      case SPI_RBM:
+        /* Assume ECON2:AUTOINC to be set */
+        if (rbmPackets.size() > 0) {
+          if (rbmPackets.element().isEmpty()) {
+            log("warning, rbm packet data is already consumed, returning 0");
+          } else {
+            // TODO: 0xff ?
+            return rbmPackets.element().remove() & 0xff;
+          }
+        } else {
+          log("warning, no packet in rbm, returning 0");
+        }
+        break;
+
+      default:
+        log("warning, spi_state ? " + spi_state);
+        break;
+    }
+
+    return 0;
+  }
+
+  public int getConfiguration(int parameter) {
+    return -1;
+  }
+
+  public int getModeMax() {
+    return -1;
+  }
+
+  @Override
+  public void dataReceived(USARTSource source, int spiIn) {
+
+    // test int -> byte -> int
+    // for (int i = 0; i <= 0xff; i++) {
+    //   byte j = (byte)i;
+    //   Assert.ok( (0xff & j) == i, " ? i " + i + " j " + j);
+    // }
+
+    Assert.ok( (spiIn & 0xff) == spiIn, " byte spiIn ? " + spiIn);
+    int spiOut = inputByte(spiIn);
+    Assert.ok( (spiOut & 0xff) == spiOut, " byte spiOut ? " + spiOut);
+    source.byteReceived(spiOut);
+    // log("Enc28J60 spiIn: 0x" + Integer.toHexString(spiIn) + ", spiOut 0x" + Integer.toHexString(spiOut));
+  }
+
+  public void plugEth() {
+    TunTap.getInstance().addObserver(tapObserver);
+  }
+
+  public void unplugEth() {
+    TunTap.getInstance().removeObserver(tapObserver);
+  }
+
+  public static boolean hasEth() {
+    try {
+      TunTap.getInstance();
+      return true;
+    } catch (LastErrorException ex) {
+      System.out.println("Enc28J60 disabled -> " + ex);
+      return false;
+    } catch (Exception ex) {
+      ex.printStackTrace();
+      return false;
+    }
+  }
+
+}
diff --git a/se/sics/mspsim/platform/proiot3/Observable.java b/se/sics/mspsim/platform/proiot3/Observable.java
new file mode 100644
index 0000000..2bdc619
--- /dev/null
+++ b/se/sics/mspsim/platform/proiot3/Observable.java
@@ -0,0 +1,39 @@
+package se.sics.mspsim.platform.proiot3;
+
+import java.util.concurrent.CopyOnWriteArrayList;
+
+
+public class Observable<ObservedType> {
+
+    public interface Observer<ObservedType> {
+        void update(ObservedType data);
+    }
+
+    private final CopyOnWriteArrayList<Observer<ObservedType>> _observers = new CopyOnWriteArrayList<Observer<ObservedType>>();
+
+    public void addObserver(Observer<ObservedType> obs) {
+        if (obs == null) {
+            throw new IllegalArgumentException("Tried to add a null observer");
+        }
+        if (_observers.contains(obs)) {
+            throw new IllegalArgumentException("Observer subscribed already");
+        }
+        _observers.add(obs);
+    }
+
+    public void removeObserver(Observer<ObservedType> obs) {
+        if (obs == null) {
+            throw new IllegalArgumentException("Tried to remove a null observer");
+        }
+        if (!_observers.contains(obs)) {
+            throw new IllegalArgumentException("No such Observer");
+        }
+        _observers.remove(obs);
+    }
+
+    protected void notifyObservers(ObservedType data) {
+        for (Observer<ObservedType> obs : _observers) {
+            obs.update(data);
+        }
+    }
+}
\ No newline at end of file
diff --git a/se/sics/mspsim/platform/proiot3/Proiot3Node.java b/se/sics/mspsim/platform/proiot3/Proiot3Node.java
new file mode 100644
index 0000000..659334c
--- /dev/null
+++ b/se/sics/mspsim/platform/proiot3/Proiot3Node.java
@@ -0,0 +1,293 @@
+package se.sics.mspsim.platform.proiot3;
+
+import se.sics.mspsim.core.MSP430Constants;
+import se.sics.mspsim.config.MSP430f1611Config;
+import se.sics.mspsim.core.IOPort;
+import se.sics.mspsim.core.IOUnit;
+import se.sics.mspsim.core.PortListener;
+import se.sics.mspsim.core.SimEvent;
+import se.sics.mspsim.core.SimEventListener;
+import se.sics.mspsim.platform.IProiotNode;
+import se.sics.mspsim.platform.GenericNode;
+import se.sics.mspsim.emulink.IEmuLinkWriter;
+import se.sics.mspsim.chip.Button;
+import se.sics.mspsim.ui.SerialMon;
+import se.sics.mspsim.core.USART;
+
+import java.util.HashMap;
+import java.awt.GraphicsEnvironment;
+
+import org.json.simple.JSONObject;
+
+
+public class Proiot3Node extends GenericNode implements IProiotNode {
+
+  // http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.12.5
+  // For all reference types (§4.3), the default value is null
+  private IEmuLinkWriter emulink;
+
+  private final Button[] buttons = new Button[8];
+
+  private final boolean hasSerialMon = !GraphicsEnvironment.isHeadless();
+
+  private Enc28J60 enc28J60;
+
+  @Override
+  public void setEmuLink(IEmuLinkWriter emulink) {
+    this.emulink = emulink;
+  }
+
+  @Override
+  public void handleMoreCmd(final String cmd, final Object value) {
+    if ("proiot$button-1".equals(cmd)) {
+      for (final Button b : buttons) {
+        b.setPressed((boolean)value);
+      }
+    } else if (cmd.startsWith("proiot$button")) {
+      final String c = cmd.substring(cmd.length() - 1);
+      buttons[Integer.parseInt(c)].setPressed((boolean)value);
+    } else {
+      Assert.fail("ProiotNode: UNHANDLED \"" + cmd + "\" !!!");
+    }
+  }
+
+  public Proiot3Node() {
+    super("ProiotNode", new MSP430f1611Config());
+
+    if (Enc28J60.hasEth()) {
+      enc28J60 = new Enc28J60(cpu, this);
+    }
+
+    setupNode();
+
+    cpu.addSimEventListener(new SimEventListener() {
+
+        private SerialMon serialMon;
+        // The methods notify() and notifyAll() do not save the method calls 
+        // to them in case no threads are waiting when they are called. 
+        // The notify signal is then just lost.
+        private boolean wasSignalled;
+
+        @Override
+        public void simChanged(SimEvent event) {
+          switch (event.getType()) {
+            case START:
+              if (enc28J60 != null) {
+                enc28J60.plugEth();
+              }
+
+              if (hasSerialMon) {
+                final Object mutex = new Object();
+                java.awt.EventQueue.invokeLater(new Runnable() {
+                  @Override
+                  public void run() {
+                    // see autorun.sc
+                    // Add some windows for listening to serial output
+                    USART usart = cpu.getIOUnit(USART.class, "USART0");
+                    Assert.ok(usart != null, "ProiotNode: USART0 ?");
+                    // see autorun.sc
+                    serialMon = new SerialMon(usart, "USART0 I/O P3(4,5)");
+                    serialMon.start();
+                    synchronized(mutex) {
+                      wasSignalled = true;
+                      mutex.notify();
+                    }
+                  }
+                });
+
+                // otherwise we can loose UART data on start
+                // to reproduce just add Thread.sleep() before serialMon.start()
+                // and remove mutex. code
+                synchronized(mutex) {
+                  if(!wasSignalled) {
+                    try {
+                      mutex.wait();
+                    } catch (InterruptedException ex) {
+                      ex.printStackTrace();
+                    }
+                  }
+                }
+              }
+              break;
+
+            case STOP:
+              System.out.println("ProiotNode: stopped " + cpu.info());
+
+              if (hasSerialMon) {
+                java.awt.EventQueue.invokeLater(new Runnable() {
+                  @Override
+                  public void run() {
+                    serialMon.stop();
+                  }
+                });
+              }
+
+              if (enc28J60 != null) {
+                enc28J60.unplugEth();
+              }
+
+              emulink.simulationStopped();
+
+              break;
+            }
+        }
+    });
+
+    System.out.println("ProiotNode: created, MSPSim " + MSP430Constants.VERSION);
+
+    // cpu.setDebug(true);
+  }
+
+  private void doEvent(String name, HashMap<String, Object> data) {
+    HashMap<String, Object> json = new HashMap<String, Object>();
+    json.put("proiot$event", name);
+    json.put("proiot$data", data);
+    json.put("proiot$ms", System.currentTimeMillis());
+    emulink.sendToSimulator(new JSONObject(json).toJSONString());
+  }
+
+  private void doEventPort(final IOPort source, final int data) {
+    HashMap<String, Object> json = new HashMap<String, Object>();
+    json.put("value", data);
+    json.put("id", source.getPort());
+    doEvent("port", json);
+  }
+
+  private void portSubscribe(final String portName) {
+    final IOPort port = cpu.getIOUnit(IOPort.class, portName);
+    port.addPortListener(new PortListener() {
+
+        private int portLastValue;
+
+        public void portWrite(final IOPort source, final int data) {
+          Assert.ok(port == source, "ProiotNode: port " + portName + " != source");
+          if (portLastValue != data) {
+            doEventPort(source, data);
+            portLastValue = data;
+          }
+        }
+    });
+  }
+
+  private void setupP2P3() {
+
+    final IOPort port2 = cpu.getIOUnit(IOPort.class, "P2"),
+                 port3 = cpu.getIOUnit(IOPort.class, "P3");
+
+    new Object() {
+
+      int port2LastValue;
+
+      // Anonymous inner classes can't have a constructor,
+      // so they're a pretty natural fit for instance initializers
+
+      {
+        port2.addPortListener(new PortListener() {
+            public void portWrite(final IOPort source, final int data) {
+              
+              // assert both listeners are in the same thread
+              // System.out.println("Thread PORT2 # " + Thread.currentThread().getId());
+
+              Assert.ok(port2 == source, "ProiotNode: port2 != source");
+              port2LastValue = data;
+            }
+        });
+
+        port3.addPortListener(new PortListener() {
+
+            int port3LastValue;
+
+            final int SSD1306_E = 0b10;
+            final int SSD1306_COMMAND_OR_DATA = 0b1;
+
+            private void ssd1306(final int data) {
+                // bit test ssd1306.E
+                if ( (data & SSD1306_E) != 0 && (port3LastValue & SSD1306_E) == 0 ) {
+                  HashMap<String, Object> json = new HashMap<String, Object>();
+                  json.put("value", port2LastValue);
+                  json.put("command", (data & SSD1306_COMMAND_OR_DATA) == 0);
+                  doEvent("ssd1306", json);
+                }
+            }
+
+            private void leds(final int data) {
+
+              final int LEDS_MASK = (hasSerialMon ? 0b11001111 : 0xFF) 
+                ^ SSD1306_E ^ SSD1306_COMMAND_OR_DATA; // P3(4,5) = USART0 TXD/RXD; 
+              
+              if ( (port3LastValue & LEDS_MASK) != (data & LEDS_MASK) ) {
+                doEventPort(port3, (data & LEDS_MASK));
+              }
+            }
+
+            public void portWrite(final IOPort source, final int data) {
+
+              // assert both listeners are in the same thread
+              // System.out.println("Thread PORT3 # " + Thread.currentThread().getId());
+
+              Assert.ok(port3 == source, "ProiotNode: port3 != source");
+
+              ssd1306(data);
+              leds(data);
+
+              port3LastValue = data;
+            }
+        });
+      }
+
+    };
+  }
+
+  private void setupP5() {
+    if (enc28J60 != null) {
+      USART usart = cpu.getIOUnit(USART.class, "USART1");
+      Assert.ok(usart != null, "ProiotNode: USART1 ?");
+      usart.addUSARTListener(enc28J60);
+    }
+
+    final int LEDS_MASK = enc28J60 == null ? 0xFF : 0b11110000;
+    final int CHIP_SELECT_MASK = 1;
+    final IOPort port = cpu.getIOUnit(IOPort.class, "P5");
+    port.addPortListener(new PortListener() {
+
+        private int portLastValue;
+
+        public void portWrite(final IOPort source, final int data) {
+          Assert.ok(port == source, "ProiotNode: port != source");          
+
+          if ((portLastValue & LEDS_MASK) != (data & LEDS_MASK)) {
+            doEventPort(source, (data & LEDS_MASK));
+          }
+
+          if (enc28J60 != null && (portLastValue & CHIP_SELECT_MASK) != (data & CHIP_SELECT_MASK)) {
+            enc28J60.chipSelect((data & CHIP_SELECT_MASK) == 0);
+          }
+
+          portLastValue = data;
+        }
+    });
+  }
+
+  private void setupNodePorts() {
+    setupP2P3();
+    portSubscribe("P4");
+    setupP5();
+    portSubscribe("P6");
+
+    final IOPort port1 = cpu.getIOUnit(IOPort.class, "P1");
+    for (int i = 0; i < buttons.length; i++) {
+      buttons[i] = new Button("Button" + i, cpu, port1, i, true);
+    }
+  }
+
+  @Override
+  public void setupNode() {
+    setupNodePorts();
+  }
+
+  @Override
+  public int getModeMax() {
+    return 0;
+  }
+
+}
diff --git a/se/sics/mspsim/platform/proiot3/TunTap.java b/se/sics/mspsim/platform/proiot3/TunTap.java
new file mode 100644
index 0000000..31a4861
--- /dev/null
+++ b/se/sics/mspsim/platform/proiot3/TunTap.java
@@ -0,0 +1,443 @@
+package se.sics.mspsim.platform.proiot3;
+
+import com.sun.jna.Platform;
+import com.sun.jna.Library;
+import com.sun.jna.Native;
+import com.sun.jna.Structure;
+import com.sun.jna.LastErrorException;
+
+// windows (jna-platform-*.jar)
+import com.sun.jna.platform.win32.Advapi32Util;
+import com.sun.jna.platform.win32.WinReg;
+import com.sun.jna.platform.win32.WinError;
+import com.sun.jna.platform.win32.WinNT;
+import com.sun.jna.platform.win32.WinioctlUtil;
+import com.sun.jna.platform.win32.Winioctl;
+import com.sun.jna.platform.win32.Win32Exception;
+import com.sun.jna.ptr.IntByReference;
+import com.sun.jna.Memory;
+
+import java.util.Arrays;
+import java.util.List;
+import java.lang.AutoCloseable;
+
+
+// https://github.com/java-native-access/jna/blob/master/www/GettingStarted.md
+
+interface CLibrary extends Library {
+
+    final CLibrary INSTANCE = (CLibrary)Native.loadLibrary(Platform.C_LIBRARY_NAME, CLibrary.class);
+
+    int ioctl(int fd, int cmd, ifReq p) throws LastErrorException;
+
+    // https://github.com/songgao/water/blob/master/syscalls_linux.go
+    // https://github.com/java-native-access/jna/blob/master/test/com/sun/jna/StructureTest.java
+
+    public static class ifReq extends Structure {
+
+        public ifReq (String name, short flags) {
+            // ASSERT: System.out.println(name.getBytes().length + " == " + name.length());
+            System.arraycopy(name.getBytes(), 0, this.Name, 0, name.length());
+            this.Flags = flags;
+        }
+
+         public byte[] Name = new byte[0x10];
+         public short Flags;
+         public byte[] pad = new byte[0x28 - 0x10 - 2];
+
+        @Override
+        protected List<String> getFieldOrder() { 
+            return Arrays.asList(new String[] { 
+                "Name", "Flags", "pad",
+            });
+        }
+    }
+
+    // RandomAccessFile + JNA alternative
+    // https://gist.github.com/c65d56eb9af48df42899053c6b13b62f
+
+    /**
+     * Open and possibly create a file or device.
+     * 
+     * @param path file path
+     * @param oflag file status flags and file access modes
+     * @return new file descriptor, or -1 if an error occurred
+     * @throws LastErrorException exception representing a non-zero
+     *             error code returned in errno
+     */
+    int open(String path, int oflag) throws LastErrorException;
+
+    /**
+     * Closes a file descriptor, so that it no longer refers to any
+     * file and may be reused.
+     * 
+     * @param fd file descriptor for already opened file
+     * @return zero on success, otherwise -1
+     * @throws LastErrorException exception representing a non-zero
+     *             error code returned in errno
+     */
+    int close(int fd) throws LastErrorException;
+
+    /**
+     * Read up to <code>count</code> bytes from file descriptor
+     * <code>fd</code> into the buffer starting at <code>buf</code>.
+     * 
+     * @param fd file descriptor of file to read from
+     * @param buf the address of buffer to read to
+     * @param count number of bytes to read
+     * @return number of read bytes on success, otherwise -1
+     * @throws LastErrorException exception representing a non-zero
+     *             error code returned in errno
+     */
+    int read(int fd, byte[] buffer, int count) throws LastErrorException;
+
+    int write(int fd, byte[] buffer, int len) throws LastErrorException;
+
+}
+
+interface ITunTap extends AutoCloseable {
+    int read(byte[] buffer);
+    int write(byte[] buffer);
+}
+
+public final class TunTap extends Observable<byte[]> {
+
+    private static volatile TunTap instance;
+
+    // https://habrahabr.ru/post/129494/
+
+    public static TunTap getInstance() {
+        TunTap localInstance = instance;
+        if (localInstance == null) {
+            synchronized (TunTap.class) {
+                localInstance = instance;
+                if (localInstance == null) {
+                    instance = localInstance = new TunTap();
+                }
+            }
+        }
+        return localInstance;
+    }
+
+    final private ITunTap tap = TunTapImpl.getTap();
+
+    private TunTap() {
+
+        // http://gee.cs.oswego.edu/dl/cpj/jmm.html
+        // Among other consequences, it is bad practice to make available the reference 
+        // to an incompletely constructed object (see §2.1.2). It can also be risky to 
+        // start new threads inside a constructor, especially in a class that may be subclassed. 
+        // Thread.start has the same memory effects as a lock release by the thread calling start, 
+        // followed by a lock acquire by the started thread. If a Runnable superclass invokes 
+        // new Thread(this).start() before subclass constructors execute, then the object might 
+        // not be fully initialized when the run method executes. Similarly, if you create and start
+        // a new thread T and then create an object X used by thread T, you cannot be sure that the 
+        // fields of X will be visible to T unless you employ synchronization surrounding all 
+        // references to object X. Or, when applicable, you can create X before starting T.
+
+        new Thread() {
+            @Override
+            public void run() {
+                try {
+                    while (true) {
+                        final byte[] frame = new byte[1500 /* MTU */];
+                        final int num = tap.read(frame);
+                        if (num > 0) {
+                          // https://stackoverflow.com/a/2591592
+                          // http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/util/Arrays.java
+                          notifyObservers(Arrays.copyOf(frame, num));
+                        } else {
+                          Assert.fail("Tap read error ( <= 0 )");
+                        }
+                    }
+                } catch (Exception ex) {
+                    ex.printStackTrace();
+                    Assert.fail("TunTap read thread error");
+                }
+            }
+        }.start();
+    }
+
+    private final Object writeLock = new Object();
+
+    public void write(byte[] buffer) {
+        synchronized(writeLock) {
+            Assert.ok(tap.write(buffer) == buffer.length, "write ?");
+        }
+    }
+}
+
+class TunTapImpl {
+
+    static ITunTap getTap() {
+      return Platform.isWindows() ? getWinTap() : Platform.isMac() ? getMacTap() : getLinuxTap();
+    }
+
+    // https://github.com/songgao/water/blob/master/syscalls_linux.go
+
+    private static ITunTap getLinuxTap() {
+
+        final String TAP_NAME = "mazko";
+
+        final int O_RDONLY = 0, O_WRONLY = 1, O_RDWR = 2;
+
+        // https://stackoverflow.com/questions/41056322/how-to-dispose-library-loaded-with-jna
+        final CLibrary INSTANCE = CLibrary.INSTANCE;
+
+        final int fd = INSTANCE.open("/dev/net/tun", O_RDWR);
+
+        final int TUNSETIFF    = 0x400454ca;
+        final short cIFF_TUN   = 0x0001;
+        final short cIFF_TAP   = 0x0002;
+        final short cIFF_NO_PI = 0x1000;
+
+        CLibrary.ifReq ifReq = new CLibrary.ifReq(TAP_NAME, (short) (cIFF_TAP | cIFF_NO_PI));
+        INSTANCE.ioctl(fd, TUNSETIFF, ifReq);
+
+        return new ITunTap() {
+            @Override
+            public int read(byte[] buffer) {
+                return INSTANCE.read(fd, buffer, buffer.length);
+            }
+
+            @Override
+            public int write(byte[] buffer) {
+                return INSTANCE.write(fd, buffer, buffer.length);
+            }
+
+            @Override
+            public void close() {
+                INSTANCE.close(fd);
+            }
+        };
+    }
+
+    // (NDIS 5) https://gist.github.com/glacjay/586892
+    // (NDIS 6) https://github.com/songgao/water/blob/master/syscalls_windows.go
+
+    interface Kernel32 extends com.sun.jna.platform.win32.Kernel32 {
+        Kernel32 INSTANCE = (Kernel32)Native.loadLibrary("kernel32", Kernel32.class, com.sun.jna.win32.W32APIOptions.DEFAULT_OPTIONS);
+
+        // this methods not included in JNA 4.4.0 Kernel32
+
+        boolean GetOverlappedResult(
+            WinNT.HANDLE hFile,
+            WinNT.OVERLAPPED lpOverlapped,
+            IntByReference lpNumberOfBytesTransferred,
+            boolean wait);
+
+        boolean ReadFile(
+            WinNT.HANDLE hFile,
+            Memory pointer,
+            int nNumberOfBytesToRead,
+            IntByReference lpNumberOfBytesRead,
+            WinNT.OVERLAPPED lpOverlapped);
+
+        boolean WriteFile(
+            WinNT.HANDLE hFile,
+            Memory pointer,
+            int nNumberOfBytesToWrite,
+            IntByReference lpNumberOfBytesWritten,
+            WinNT.OVERLAPPED lpOverlapped);
+    }
+
+    private static ITunTap getWinTap() {
+
+        final String REG_KEY = "SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}";
+
+        return new ITunTap() {
+
+            final Kernel32 api = Kernel32.INSTANCE;
+
+            private String getDeviceGuid() {
+              for (String s: Advapi32Util.registryGetKeys(WinReg.HKEY_LOCAL_MACHINE, REG_KEY)) {
+                  try {
+                      String k2 = REG_KEY + "\\" + s;
+                      if (Advapi32Util.registryGetStringValue(WinReg.HKEY_LOCAL_MACHINE, k2, "ComponentId").equals("tap0901")) {
+                          return Advapi32Util.registryGetStringValue(WinReg.HKEY_LOCAL_MACHINE, k2, "NetCfgInstanceId");
+                      }
+                  } catch (Exception ex) {
+                      // System.err.println("registryGetStringValue ? " + s);
+                      // ex.printStackTrace();
+                  }
+              }
+
+              throw new UnsupportedOperationException("GUID not found");
+            }
+
+            private int tap_control_code(int request, int method) {
+              return WinioctlUtil.CTL_CODE(Winioctl.FILE_DEVICE_UNKNOWN, request, method, 0);
+            }
+
+            // setStatus is used to bring up or bring down the interface
+            private void setStatus(boolean status, WinNT.HANDLE hFile) {
+
+              final int TAP_IOCTL_SET_MEDIA_STATUS = tap_control_code(6, 0);
+
+              IntByReference lpBytesReturned = new IntByReference(), 
+                             lpInBuffer = new IntByReference(status ? 1 : 0);
+
+              // https://golang.org/src/syscall/ztypes_windows.go
+              final int MAXIMUM_REPARSE_DATA_BUFFER_SIZE = 16 * 1024;
+              Memory readBuffer = new Memory(MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
+
+              if(!api.DeviceIoControl(hFile,
+                  TAP_IOCTL_SET_MEDIA_STATUS,
+                  lpInBuffer.getPointer(),
+                  4,
+                  readBuffer,
+                  MAXIMUM_REPARSE_DATA_BUFFER_SIZE,
+                  lpBytesReturned,
+                  null)) {
+                  throw new Win32Exception(api.GetLastError());
+              }
+            }
+
+            private WinNT.HANDLE getFd() {
+              final String deviceid = getDeviceGuid();
+
+              final WinNT.HANDLE hFile =  api.CreateFile(
+                  "\\\\.\\Global\\" + deviceid + ".tap",
+                  WinNT.GENERIC_READ | WinNT.GENERIC_WRITE,
+                  WinNT.FILE_SHARE_READ | WinNT.FILE_SHARE_WRITE,
+                  /* If lpSecurityAttributes is NULL, the handle cannot be inherited */
+                  null, WinNT.OPEN_EXISTING,
+                  WinNT.FILE_ATTRIBUTE_SYSTEM | WinNT.FILE_FLAG_OVERLAPPED,
+                  null);
+
+              // bring up device
+              setStatus(true, hFile);
+
+              return hFile;
+            }
+
+            // https://github.com/traff/pty4j/blob/master/src/com/pty4j/windows/NamedPipe.java
+            // https://github.com/facebook/buck/blob/master/src/com/facebook/buck/io/windowspipe/WindowsNamedPipe.java
+
+            private final WinNT.HANDLE hFile = getFd();
+            private final WinNT.HANDLE readEvent = createEvent();
+            private final WinNT.HANDLE writeEvent = createEvent();
+
+            private WinNT.HANDLE createEvent() {
+              WinNT.HANDLE event = api.CreateEvent(null, true, false, null);
+              if (event == null) {
+                throw new Win32Exception(api.GetLastError());
+              }
+              return event;
+            }
+
+            private WinNT.OVERLAPPED createOverlapped(WinNT.HANDLE event) {
+              WinNT.OVERLAPPED olap = new WinNT.OVERLAPPED();
+              olap.hEvent = event;
+              // JNA doc write(): Writes the fields of the struct to native memory
+              olap.write();
+              return olap;
+            }
+
+            @Override
+            public int read(byte[] buffer) {
+              int n;
+              do {
+                n = readImpl(buffer);
+                if (n == 0) {
+                  System.out.println("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
+                  System.out.println("!!!!!! Windows tap read 0 workaround !!!!!!");
+                  System.out.println("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
+                }
+              } while(n == 0);
+              return n;
+            }
+
+            private int readImpl(byte[] buffer) {
+
+                Memory readBuffer = new Memory(buffer.length);
+
+                WinNT.OVERLAPPED readOver = createOverlapped(readEvent);
+                if (!api.ReadFile(hFile, readBuffer, buffer.length, null, readOver) && 
+                    api.GetLastError() != WinError.ERROR_IO_PENDING) {
+                    throw new Win32Exception(api.GetLastError());
+                }
+
+                IntByReference lpNumberOfBytesRead = new IntByReference();
+
+                // wait = true, blocked until data is read
+                if (!api.GetOverlappedResult(hFile, readOver, lpNumberOfBytesRead, true)) {
+                  throw new Win32Exception(api.GetLastError());
+                }
+
+                int readValue = lpNumberOfBytesRead.getValue();
+                readBuffer.read(0, buffer, 0, readValue);
+
+                return readValue;
+            }
+
+            @Override
+            public int write(byte[] buffer) {
+
+                Memory writeBuffer = new Memory(buffer.length);
+                writeBuffer.write(0, buffer, 0, buffer.length);
+
+                WinNT.OVERLAPPED writeOver = createOverlapped(writeEvent);
+                if (!api.WriteFile(hFile, writeBuffer, buffer.length, null, writeOver) && 
+                    api.GetLastError() != WinError.ERROR_IO_PENDING) {
+                    throw new Win32Exception(api.GetLastError());
+                }
+
+                IntByReference lpNumberOfBytesWritten = new IntByReference();
+
+                // wait = true, blocked until data is written
+                if (!api.GetOverlappedResult(hFile, writeOver, lpNumberOfBytesWritten, true)) {
+                  throw new Win32Exception(api.GetLastError());
+                }
+
+                return lpNumberOfBytesWritten.getValue();
+            }
+
+            @Override
+            public void close() {
+                api.CloseHandle(hFile);
+                api.CloseHandle(readEvent);
+                api.CloseHandle(writeEvent);
+            }
+        };
+    }
+
+    private static ITunTap getMacTap() {
+        throw new UnsupportedOperationException("TODO: Mac not supported yet");
+    }
+
+    public static void main(String args[]) throws Exception {
+
+        // Linux:
+        // sudo ip tuntap add mazko mode tap user $USER
+        // run me
+        // sudo ip addr add 10.0.0.1/24 dev mazko && sudo ip link set dev mazko up && ping 10.0.0.42
+        // sudo ip tuntap delete mazko mode tap
+
+        // Windows:
+        // install Tap-windows driver from OpenVPN site
+        // Start -> Control Panel -> Network Connections rename "TAP-Windows Adapter" to mazko
+        // netsh interface ip set address mazko static 10.0.0.1 255.255.255.0
+        // run me
+        // ping 10.0.0.42
+
+        // run me
+        // javac -cp ../../../../../lib/jna-4.4.0.jar:../../../../../lib/jna-platform-4.4.0.jar TunTap.java Observable.java Assert.java
+        // java -cp ../../../../../lib/jna-4.4.0.jar:../../../../../lib/jna-platform-4.4.0.jar:../../../../../ se.sics.mspsim.platform.proiot3.TunTapImpl
+
+        try (ITunTap tap = getTap()) {
+            while (true) {
+                byte[] frame = new byte[1500];
+                int num = tap.read(frame);
+                if (num > 0) {
+                  System.out.println(Arrays.toString(Arrays.copyOf(frame, num)));
+                  System.out.println();
+                  // System.out.println(Arrays.toString(frame));
+                  // System.out.println();
+                } else {
+                  throw new Exception("num ? " + num);
+                }
+            }
+        } 
+    }
+}
\ No newline at end of file
diff --git a/se/sics/mspsim/platform/proiot4/Assert.java b/se/sics/mspsim/platform/proiot4/Assert.java
new file mode 100644
index 0000000..8d31a57
--- /dev/null
+++ b/se/sics/mspsim/platform/proiot4/Assert.java
@@ -0,0 +1,18 @@
+package se.sics.mspsim.platform.proiot4;
+
+
+public final class Assert {
+
+  private Assert() {}
+
+  static void ok(boolean cond, String msg) {
+    if (!cond) {
+      System.err.println("!!! ASSERT !!!: " + msg);
+      System.exit(42);
+    }
+  }
+
+  static void fail(String msg) {
+    ok(false, msg);
+  }
+}
diff --git a/se/sics/mspsim/platform/proiot4/Proiot4Node.java b/se/sics/mspsim/platform/proiot4/Proiot4Node.java
new file mode 100644
index 0000000..9bdd555
--- /dev/null
+++ b/se/sics/mspsim/platform/proiot4/Proiot4Node.java
@@ -0,0 +1,197 @@
+package se.sics.mspsim.platform.proiot4;
+
+import se.sics.mspsim.core.MSP430Constants;
+import se.sics.mspsim.config.MSP430f1611Config;
+import se.sics.mspsim.core.IOPort;
+import se.sics.mspsim.core.IOUnit;
+import se.sics.mspsim.core.PortListener;
+import se.sics.mspsim.core.SimEvent;
+import se.sics.mspsim.core.SimEventListener;
+import se.sics.mspsim.platform.IProiotNode;
+import se.sics.mspsim.platform.GenericNode;
+import se.sics.mspsim.emulink.IEmuLinkWriter;
+import se.sics.mspsim.ui.SerialMon;
+import se.sics.mspsim.core.USART;
+
+import java.util.HashMap;
+import java.awt.GraphicsEnvironment;
+
+import org.json.simple.JSONObject;
+
+
+public class Proiot4Node extends GenericNode implements IProiotNode {
+
+  // http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.12.5
+  // For all reference types (§4.3), the default value is null
+  private IEmuLinkWriter emulink;
+
+  private final boolean hasSerialMon = !GraphicsEnvironment.isHeadless();
+
+  @Override
+  public void setEmuLink(IEmuLinkWriter emulink) {
+    this.emulink = emulink;
+  }
+
+  @Override
+  public void handleMoreCmd(final String cmd, final Object value) {
+    Assert.fail("ProiotNode: UNHANDLED \"" + cmd + "\" !!!");
+  }
+
+  public Proiot4Node() {
+    super("ProiotNode", new MSP430f1611Config());
+
+    setupNode();
+
+    cpu.addSimEventListener(new SimEventListener() {
+
+        private SerialMon serialMon;
+        // The methods notify() and notifyAll() do not save the method calls 
+        // to them in case no threads are waiting when they are called. 
+        // The notify signal is then just lost.
+        private boolean wasSignalled;
+
+        @Override
+        public void simChanged(SimEvent event) {
+          switch (event.getType()) {
+            case START:
+              if (hasSerialMon) {
+                final Object mutex = new Object();
+                java.awt.EventQueue.invokeLater(new Runnable() {
+                  @Override
+                  public void run() {
+                    // see autorun.sc
+                    // Add some windows for listening to serial output
+                    USART usart = cpu.getIOUnit(USART.class, "USART0");
+                    Assert.ok(usart != null, "ProiotNode: USART0 ?");
+                    // see autorun.sc
+                    serialMon = new SerialMon(usart, "USART0 I/O P3(4,5)");
+                    serialMon.start();
+                    synchronized(mutex) {
+                      wasSignalled = true;
+                      mutex.notify();
+                    }
+                  }
+                });
+
+                // otherwise we can loose UART data on start
+                // to reproduce just add Thread.sleep() before serialMon.start()
+                // and remove mutex. code
+                synchronized(mutex) {
+                  if(!wasSignalled) {
+                    try {
+                      mutex.wait();
+                    } catch (InterruptedException ex) {
+                      ex.printStackTrace();
+                    }
+                  }
+                }
+              }
+              break;
+
+            case STOP:
+              System.out.println("ProiotNode: stopped " + cpu.info());
+
+              if (hasSerialMon) {
+                java.awt.EventQueue.invokeLater(new Runnable() {
+                  @Override
+                  public void run() {
+                    serialMon.stop();
+                  }
+                });
+              }
+
+              emulink.simulationStopped();
+
+              break;
+            }
+        }
+    });
+
+    System.out.println("ProiotNode: created, MSPSim " + MSP430Constants.VERSION);
+
+    // cpu.setDebug(true);
+  }
+
+  private void doEvent(String name, HashMap<String, Object> data) {
+    HashMap<String, Object> json = new HashMap<String, Object>();
+    json.put("proiot$event", name);
+    json.put("proiot$data", data);
+    json.put("proiot$ms", System.currentTimeMillis());
+    emulink.sendToSimulator(new JSONObject(json).toJSONString());
+  }
+
+  private void doEventPort(final IOPort source, final int data) {
+    HashMap<String, Object> json = new HashMap<String, Object>();
+    json.put("value", data);
+    json.put("id", source.getPort());
+    doEvent("port", json);
+  }
+
+  private void portSubscribe(final String portName) {
+    final IOPort port = cpu.getIOUnit(IOPort.class, portName);
+    port.addPortListener(new PortListener() {
+
+        private int portLastValue;
+
+        public void portWrite(final IOPort source, final int data) {
+          Assert.ok(port == source, "ProiotNode: port " + portName + " != source");
+          if (portLastValue != data) {
+            doEventPort(source, data);
+            portLastValue = data;
+          }
+        }
+    });
+  }
+
+  private void setupP3() {
+
+    final IOPort port3 = cpu.getIOUnit(IOPort.class, "P3");
+
+    port3.addPortListener(new PortListener() {
+
+        int port3LastValue;
+
+        private void leds(final int data) {
+
+          final int LEDS_MASK = (hasSerialMon ? 0b11001111 : 0xFF);
+          
+          if ( (port3LastValue & LEDS_MASK) != (data & LEDS_MASK) ) {
+            doEventPort(port3, (data & LEDS_MASK));
+          }
+        }
+
+        public void portWrite(final IOPort source, final int data) {
+
+          // assert both listeners are in the same thread
+          // System.out.println("Thread PORT3 # " + Thread.currentThread().getId());
+
+          Assert.ok(port3 == source, "ProiotNode: port3 != source");
+
+          leds(data);
+
+          port3LastValue = data;
+        }
+    });
+
+  }
+
+  private void setupNodePorts() {
+    portSubscribe("P1");
+    portSubscribe("P2");
+    setupP3();
+    portSubscribe("P4");
+    portSubscribe("P5");
+    portSubscribe("P6");
+  }
+
+  @Override
+  public void setupNode() {
+    setupNodePorts();
+  }
+
+  @Override
+  public int getModeMax() {
+    return 0;
+  }
+
+}
diff --git a/se/sics/mspsim/ui/SerialMon.java b/se/sics/mspsim/ui/SerialMon.java
index 1099ae7..44c9beb 100644
--- a/se/sics/mspsim/ui/SerialMon.java
+++ b/se/sics/mspsim/ui/SerialMon.java
@@ -203,7 +203,7 @@ public class SerialMon implements USARTListener, StateChangeListener, ServiceCom
   public final void stop() {
     status = Status.STOPPED;
     if (window != null) {
-      window.setVisible(false);
+      window.dispose();
     }
     usart.removeUSARTListener(this);
     usart.removeStateChangeListener(this);
